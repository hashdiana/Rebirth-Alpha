//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "G:\PortableSoft\JBY\MC_Deobf3000\1.12-MCP-Mappings"!

package me.rebirthclient.mod.modules.impl.exploit;

import me.rebirthclient.mod.modules.Category;
import me.rebirthclient.mod.modules.Module;
import me.rebirthclient.mod.modules.impl.movement.Sprint;
import me.rebirthclient.mod.modules.settings.Setting;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.util.math.MathHelper;

public class Clip extends Module {
   public static Clip INSTANCE;
   private final Setting<Integer> delay = this.add(new Setting<>("delay", 5, 1, 10));
   private final Setting<Integer> timeout = this.add(new Setting<>("Timeout", 5, 1, 60));
   private int packets;
   int ticks = 0;

   public Clip() {
      super("Clip", "Clips into blocks nearby to prevent crystal damage", Category.EXPLOIT);
      INSTANCE = this;
   }

   @Override
   public void onDisable() {
      this.packets = 0;
      this.ticks = 0;
   }

   @Override
   public String getInfo() {
      return String.valueOf(this.packets);
   }

   @Override
   public void onUpdate() {
      if (Sprint.isMoving()) {
         this.ticks = 0;
      } else {
         ++this.ticks;
         if (this.ticks <= this.timeout.getValue()) {
            if (mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().grow(0.01, 0.0, 0.01)).size() < 2) {
               mc.player
                  .setPosition(
                     this.roundToClosest(
                        mc.player.posX, Math.floor(mc.player.posX) + 0.301, Math.floor(mc.player.posX) + 0.699
                     ),
                     mc.player.posY,
                     this.roundToClosest(
                        mc.player.posZ, Math.floor(mc.player.posZ) + 0.301, Math.floor(mc.player.posZ) + 0.699
                     )
                  );
               this.packets = 0;
            } else if (mc.player.ticksExisted % this.delay.getValue() == 0) {
               mc.player
                  .setPosition(
                     mc.player.posX
                        + MathHelper.clamp(
                           this.roundToClosest(
                                 mc.player.posX,
                                 Math.floor(mc.player.posX) + 0.241,
                                 Math.floor(mc.player.posX) + 0.759
                              )
                              - mc.player.posX,
                           -0.03,
                           0.03
                        ),
                     mc.player.posY,
                     mc.player.posZ
                        + MathHelper.clamp(
                           this.roundToClosest(
                                 mc.player.posZ,
                                 Math.floor(mc.player.posZ) + 0.241,
                                 Math.floor(mc.player.posZ) + 0.759
                              )
                              - mc.player.posZ,
                           -0.03,
                           0.03
                        )
                  );
               mc.player
                  .connection
                  .sendPacket(new Position(mc.player.posX, mc.player.posY, mc.player.posZ, true));
               mc.player
                  .connection
                  .sendPacket(
                     new Position(
                        this.roundToClosest(
                           mc.player.posX,
                           Math.floor(mc.player.posX) + 0.23,
                           Math.floor(mc.player.posX) + 0.77
                        ),
                        mc.player.posY,
                        this.roundToClosest(
                           mc.player.posZ,
                           Math.floor(mc.player.posZ) + 0.23,
                           Math.floor(mc.player.posZ) + 0.77
                        ),
                        true
                     )
                  );
               ++this.packets;
            }
         }
      }
   }

   private double roundToClosest(double num, double low, double high) {
      double d1 = num - low;
      double d2 = high - num;
      return d2 > d1 ? low : high;
   }
}
