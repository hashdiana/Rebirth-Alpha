//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "G:\PortableSoft\JBY\MC_Deobf3000\1.12-MCP-Mappings"!

package me.rebirthclient.mod.modules.impl.exploit;

import java.util.Arrays;
import java.util.List;
import me.rebirthclient.api.util.EntityUtil;
import me.rebirthclient.api.util.troll.Function2;
import me.rebirthclient.api.util.troll.RayTraceAction;
import me.rebirthclient.api.util.troll.RaytraceKt;
import me.rebirthclient.mod.modules.Category;
import me.rebirthclient.mod.modules.Module;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.init.Blocks;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.RayTraceResult.Type;
import net.minecraft.world.World;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

public class GhostHand extends Module {
   public static GhostHand INSTANCE;
   private static final List<String> blockList = Arrays.asList("minecraft:bedrock", "minecraft:portal_frame", "minecraft:portal");
   private static final Function2<BlockPos, IBlockState, RayTraceAction> function = GhostHand::function$lambda;

   public GhostHand() {
      super("GhostHand", "", Category.EXPLOIT);
      INSTANCE = this;
   }

   public static void handleRayTrace(double blockReachDistance, float partialTicks, CallbackInfoReturnable<RayTraceResult> cir) {
      if (!INSTANCE.isOff()) {
         if (mc.currentScreen == null) {
            if (Keyboard.isKeyDown(56) || Keyboard.isKeyDown(184)) {
               return;
            }

            if (Keyboard.isKeyDown(29) || Keyboard.isKeyDown(157)) {
               return;
            }

            if (Mouse.isButtonDown(1)) {
               return;
            }
         }

         EntityPlayerSP player = mc.player;
         if (player != null) {
            Vec3d eyePos = EntityUtil.getEyePosition(player);
            Vec3d lookVec = player.getLook(partialTicks);
            Vec3d sightEnd = eyePos.add(
               lookVec.x * blockReachDistance, lookVec.y * blockReachDistance, lookVec.z * blockReachDistance
            );
            World world = player.world;
            RayTraceResult rayTrace;
            if ((rayTrace = RaytraceKt.rayTrace(world, eyePos, sightEnd, 50, function)) == null) {
               Type miss = Type.MISS;
               EnumFacing up = EnumFacing.UP;
               double $this$fastFloor$iv$iv = sightEnd.x;
               int n2 = (int)($this$fastFloor$iv$iv + 1.07374182E9F) - 1073741824;
               $this$fastFloor$iv$iv = sightEnd.y;
               int n3 = (int)($this$fastFloor$iv$iv + 1.07374182E9F) - 1073741824;
               $this$fastFloor$iv$iv = sightEnd.z;
               BlockPos blockPos = new BlockPos(n2, n3, (int)($this$fastFloor$iv$iv + 1.07374182E9F) - 1073741824);
               rayTrace = new RayTraceResult(miss, sightEnd, up, blockPos);
            }

            cir.setReturnValue(rayTrace);
         }
      }
   }

   private static RayTraceAction function$lambda(BlockPos blockPos, IBlockState blockState) {
      Block block = blockState.getBlock();
      if (block != Blocks.AIR && block.canCollideCheck(blockState, false)) {
         boolean ignoreListed = true;
         if (ignoreListed != blockList.contains(String.valueOf(block.getRegistryName()))) {
            RayTraceAction rayTraceAction = RayTraceAction.Calc.INSTANCE;
            return rayTraceAction;
         }
      }

      RayTraceAction rayTraceAction = RayTraceAction.Skip.INSTANCE;
      return rayTraceAction;
   }
}
