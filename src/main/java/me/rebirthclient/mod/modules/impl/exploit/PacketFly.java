//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "G:\PortableSoft\JBY\MC_Deobf3000\1.12-MCP-Mappings"!

package me.rebirthclient.mod.modules.impl.exploit;

import io.netty.util.internal.ConcurrentSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import me.rebirthclient.api.events.impl.MoveEvent;
import me.rebirthclient.api.events.impl.PacketEvent;
import me.rebirthclient.api.events.impl.PushEvent;
import me.rebirthclient.api.events.impl.UpdateWalkingPlayerEvent;
import me.rebirthclient.api.util.MovementUtil;
import me.rebirthclient.api.util.Timer;
import me.rebirthclient.mod.modules.Category;
import me.rebirthclient.mod.modules.Module;
import me.rebirthclient.mod.modules.settings.Setting;
import net.minecraft.client.gui.GuiDownloadTerrain;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.network.play.client.CPacketPlayer.Rotation;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class PacketFly extends Module {
   public static PacketFly INSTANCE;
   public final Setting<Boolean> flight = this.add(new Setting<>("Flight", true).setParent());
   public final Setting<Integer> flightMode = this.add(new Setting<>("FMode", 0, 0, 1, v -> this.flight.isOpen()));
   public final Setting<Double> antiFactor = this.add(new Setting<>("AntiFactor", 1.0, 0.1, 3.0));
   public final Setting<Double> extraFactor = this.add(new Setting<>("ExtraFactor", 1.0, 0.1, 3.0));
   public final Setting<Boolean> strafeFactor = this.add(new Setting<>("StrafeFactor", true));
   public final Setting<Integer> loops = this.add(new Setting<>("Loops", 1, 1, 10));
   public final Setting<Boolean> clearMap = this.add(new Setting<>("ClearMap", true));
   public final Setting<Integer> clearTime = this.add(new Setting<>("ClearTime", 30, 1, 500));
   public final Setting<Boolean> clearIDs = this.add(new Setting<>("ClearIDs", true));
   public final Setting<Boolean> antiRotation = this.add(new Setting<>("AntiRotation", false));
   public final Setting<Boolean> setID = this.add(new Setting<>("SetID", true));
   public final Setting<Boolean> setMove = this.add(new Setting<>("SetMove", false));
   public final Setting<Boolean> nocliperino = this.add(new Setting<>("NoClip", false));
   public final Setting<Boolean> sendTeleport = this.add(new Setting<>("Teleport", true));
   public final Setting<Boolean> setPos = this.add(new Setting<>("SetPos", false));
   public final Setting<Boolean> invalidPacket = this.add(new Setting<>("InvalidPacket", true));
   private final Set<CPacketPlayer> packets = new ConcurrentSet();
   private final Map<Integer, PacketFly.IDtime> teleportmap = new ConcurrentHashMap<>();
   private int flightCounter = 0;
   private int teleportID = 0;

   public PacketFly() {
      super("PacketFly", "Uses packets to fly!", Category.EXPLOIT);
      INSTANCE = this;
   }

   @Override
   public void onTick() {
      this.teleportmap
         .entrySet()
         .removeIf(idTime -> this.clearMap.getValue() && idTime.getValue().getTimer().passed((long)this.clearTime.getValue().intValue()));
   }

   @SubscribeEvent
   public void onUpdateWalkingPlayer(UpdateWalkingPlayerEvent event) {
      if (!fullNullCheck()) {
         if (event.getStage() != 1) {
            mc.player.setVelocity(0.0, 0.0, 0.0);
            boolean checkCollisionBoxes = this.checkHitBoxes();
            double speed = mc.player.movementInput.jump && (checkCollisionBoxes || !MovementUtil.isMoving())
               ? (
                  this.flight.getValue() && !checkCollisionBoxes
                     ? (this.flightMode.getValue() == 0 ? (this.resetCounter(10) ? -0.032 : 0.062) : (this.resetCounter(20) ? -0.032 : 0.062))
                     : 0.062
               )
               : (
                  mc.player.movementInput.sneak
                     ? -0.062
                     : (!checkCollisionBoxes ? (this.resetCounter(4) ? (this.flight.getValue() ? -0.04 : 0.0) : 0.0) : 0.0)
               );
            if (checkCollisionBoxes && MovementUtil.isMoving() && speed != 0.0) {
               speed /= this.antiFactor.getValue();
            }

            double[] strafing = this.getMotion(this.strafeFactor.getValue() && checkCollisionBoxes ? 0.031 : 0.26);

            for(int i = 1; i < this.loops.getValue() + 1; ++i) {
               mc.player.motionX = strafing[0] * (double)i * this.extraFactor.getValue();
               mc.player.motionY = speed * (double)i;
               mc.player.motionZ = strafing[1] * (double)i * this.extraFactor.getValue();
               this.sendPackets(mc.player.motionX, mc.player.motionY, mc.player.motionZ, this.sendTeleport.getValue());
            }
         }
      }
   }

   @SubscribeEvent
   public void onMove(MoveEvent event) {
      if (!fullNullCheck()) {
         if (this.setMove.getValue() && this.flightCounter != 0) {
            event.setX(mc.player.motionX);
            event.setY(mc.player.motionY);
            event.setZ(mc.player.motionZ);
            if (this.nocliperino.getValue() && this.checkHitBoxes()) {
               mc.player.noClip = true;
            }
         }
      }
   }

   @SubscribeEvent
   public void onPacketSend(PacketEvent.Send event) {
      if (!fullNullCheck()) {
         if (event.getPacket() instanceof CPacketPlayer && !this.packets.remove((CPacketPlayer)event.getPacket())) {
            if (event.getPacket() instanceof Rotation && !this.antiRotation.getValue()) {
               return;
            }

            event.setCanceled(true);
         }
      }
   }

   @SubscribeEvent
   public void onPushOutOfBlocks(PushEvent event) {
      if (!fullNullCheck()) {
         if (event.getStage() == 1) {
            event.setCanceled(true);
         }
      }
   }

   @SubscribeEvent
   public void onReceivePacket(PacketEvent.Receive event) {
      if (!fullNullCheck()) {
         if (!event.isCanceled()) {
            if (event.getPacket() instanceof SPacketPlayerPosLook) {
               SPacketPlayerPosLook packet = event.getPacket();
               if (mc.player.isEntityAlive()
                  && mc.world
                     .isBlockLoaded(new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ), false)
                  && !(mc.currentScreen instanceof GuiDownloadTerrain)
                  && this.clearIDs.getValue()) {
                  this.teleportmap.remove(packet.getTeleportId());
               }

               if (this.setID.getValue()) {
                  this.teleportID = packet.getTeleportId();
               }
            }
         }
      }
   }

   private boolean checkHitBoxes() {
      return !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(-0.0625, -0.0625, -0.0625)).isEmpty();
   }

   private boolean resetCounter(int counter) {
      if (++this.flightCounter >= counter) {
         this.flightCounter = 0;
         return true;
      } else {
         return false;
      }
   }

   private double[] getMotion(double speed) {
      float moveForward = mc.player.movementInput.moveForward;
      float moveStrafe = mc.player.movementInput.moveStrafe;
      float rotationYaw = mc.player.prevRotationYaw + (mc.player.rotationYaw - mc.player.prevRotationYaw) * mc.getRenderPartialTicks();
      if (moveForward != 0.0F) {
         if (moveStrafe > 0.0F) {
            rotationYaw += (float)(moveForward > 0.0F ? -45 : 45);
         } else if (moveStrafe < 0.0F) {
            rotationYaw += (float)(moveForward > 0.0F ? 45 : -45);
         }

         moveStrafe = 0.0F;
         if (moveForward > 0.0F) {
            moveForward = 1.0F;
         } else if (moveForward < 0.0F) {
            moveForward = -1.0F;
         }
      }

      double posX = (double)moveForward * speed * -Math.sin(Math.toRadians((double)rotationYaw))
         + (double)moveStrafe * speed * Math.cos(Math.toRadians((double)rotationYaw));
      double posZ = (double)moveForward * speed * Math.cos(Math.toRadians((double)rotationYaw))
         - (double)moveStrafe * speed * -Math.sin(Math.toRadians((double)rotationYaw));
      return new double[]{posX, posZ};
   }

   private void sendPackets(double x, double y, double z, boolean teleport) {
      Vec3d vec = new Vec3d(x, y, z);
      Vec3d position = mc.player.getPositionVector().add(vec);
      Vec3d outOfBoundsVec = this.outOfBoundsVec(position);
      this.packetSender(new Position(position.x, position.y, position.z, mc.player.onGround));
      if (this.invalidPacket.getValue()) {
         this.packetSender(
            new Position(outOfBoundsVec.x, outOfBoundsVec.y, outOfBoundsVec.z, mc.player.onGround)
         );
      }

      if (this.setPos.getValue()) {
         mc.player.setPosition(position.x, position.y, position.z);
      }

      this.teleportPacket(position, teleport);
   }

   private void teleportPacket(Vec3d pos, boolean shouldTeleport) {
      if (shouldTeleport) {
         mc.player.connection.sendPacket(new CPacketConfirmTeleport(++this.teleportID));
         this.teleportmap.put(this.teleportID, new PacketFly.IDtime(pos, new Timer()));
      }
   }

   private Vec3d outOfBoundsVec(Vec3d position) {
      return position.add(0.0, 1337.0, 0.0);
   }

   private void packetSender(CPacketPlayer packet) {
      this.packets.add(packet);
      mc.player.connection.sendPacket(packet);
   }

   public static class IDtime {
      private final Vec3d pos;
      private final Timer timer;

      public IDtime(Vec3d pos, Timer timer) {
         this.pos = pos;
         this.timer = timer;
         this.timer.reset();
      }

      public Vec3d getPos() {
         return this.pos;
      }

      public Timer getTimer() {
         return this.timer;
      }
   }
}
