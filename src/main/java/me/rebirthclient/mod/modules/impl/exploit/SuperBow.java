//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "G:\PortableSoft\JBY\MC_Deobf3000\1.12-MCP-Mappings"!

package me.rebirthclient.mod.modules.impl.exploit;

import java.util.Random;
import java.util.regex.Pattern;
import me.rebirthclient.api.events.impl.PacketEvent;
import me.rebirthclient.api.util.Timer;
import me.rebirthclient.mod.modules.Category;
import me.rebirthclient.mod.modules.Module;
import me.rebirthclient.mod.modules.settings.Setting;
import net.minecraft.init.Items;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.network.play.client.CPacketPlayer.PositionRotation;
import net.minecraft.network.play.client.CPacketPlayerDigging.Action;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class SuperBow extends Module {
   private final Timer delayTimer = new Timer();
   private final Setting<Boolean> rotation = this.add(new Setting<>("Rotation", false));
   private final Setting<String> spoofs = this.register(new Setting<>("Spoofs", "10"));
   private final Setting<SuperBow.exploitEn> exploit = this.add(new Setting<>("Exploit", SuperBow.exploitEn.Strong));
   private final Setting<Boolean> minimize = this.add(new Setting<>("Minimize", false));
   private final Setting<Float> delay = this.add(new Setting<>("Delay", 5.0F, 0.0F, 10.0F));
   private final Setting<Float> activeTime = this.add(new Setting<>("ActiveTime", 0.4F, 0.0F, 3.0F));
   private final Random random = new Random();
   private final Timer activeTimer = new Timer();

   public SuperBow() {
      super("SuperBow", "exploit", Category.EXPLOIT);
   }

   public static boolean isInteger(String str) {
      Pattern pattern = Pattern.compile("^[-\\+]?[\\d]*$");
      return pattern.matcher(str).matches();
   }

   @Override
   public void onTick() {
      if (!mc.player.isHandActive() || mc.player.getActiveItemStack().getItem() != Items.BOW) {
         this.activeTimer.reset();
      }
   }

   @SubscribeEvent
   protected void onPacketSend(PacketEvent.Send event) {
      if (!fullNullCheck()
         && this.delayTimer.passedMs((long)(this.delay.getValue() * 1000.0F))
         && this.activeTimer.passedMs((long)(this.activeTime.getValue() * 1000.0F))) {
         if (isInteger(this.spoofs.getValue())) {
            if (event.getPacket() instanceof CPacketPlayerDigging && ((CPacketPlayerDigging)event.getPacket()).getAction() == Action.RELEASE_USE_ITEM) {
               mc.player
                  .connection
                  .sendPacket(new CPacketEntityAction(mc.player, net.minecraft.network.play.client.CPacketEntityAction.Action.START_SPRINTING));
               double[] strict_direction = new double[]{
                  100.0 * -Math.sin(Math.toRadians((double)mc.player.rotationYaw)),
                  100.0 * Math.cos(Math.toRadians((double)mc.player.rotationYaw))
               };
               if (this.exploit.getValue() == SuperBow.exploitEn.Fast) {
                  for(int i = 0; i < this.getRuns(); ++i) {
                     this.spoof(
                        mc.player.posX,
                        this.minimize.getValue() ? mc.player.posY : mc.player.posY - 1.0E-1,
                        mc.player.posZ,
                        true
                     );
                     this.spoof(mc.player.posX, mc.player.posY + 1.0E-1, mc.player.posZ, false);
                  }
               }

               if (this.exploit.getValue() == SuperBow.exploitEn.Strong) {
                  for(int i = 0; i < this.getRuns(); ++i) {
                     this.spoof(mc.player.posX, mc.player.posY + 1.0E-1, mc.player.posZ, false);
                     this.spoof(
                        mc.player.posX,
                        this.minimize.getValue() ? mc.player.posY : mc.player.posY - 1.0E-1,
                        mc.player.posZ,
                        true
                     );
                  }
               }

               if (this.exploit.getValue() == SuperBow.exploitEn.Phobos) {
                  for(int i = 0; i < this.getRuns(); ++i) {
                     this.spoof(mc.player.posX, mc.player.posY + 1.3E-13, mc.player.posZ, true);
                     this.spoof(mc.player.posX, mc.player.posY + 2.7E-13, mc.player.posZ, false);
                  }
               }

               if (this.exploit.getValue() == SuperBow.exploitEn.Strict) {
                  for(int i = 0; i < this.getRuns(); ++i) {
                     if (this.random.nextBoolean()) {
                        this.spoof(
                           mc.player.posX - strict_direction[0],
                           mc.player.posY,
                           mc.player.posZ - strict_direction[1],
                           false
                        );
                     } else {
                        this.spoof(
                           mc.player.posX + strict_direction[0],
                           mc.player.posY,
                           mc.player.posZ + strict_direction[1],
                           true
                        );
                     }
                  }
               }

               this.delayTimer.reset();
            }
         }
      }
   }

   private void spoof(double x, double y, double z, boolean ground) {
      if (this.rotation.getValue()) {
         mc.player.connection.sendPacket(new PositionRotation(x, y, z, mc.player.rotationYaw, mc.player.rotationPitch, ground));
      } else {
         mc.player.connection.sendPacket(new Position(x, y, z, ground));
      }
   }

   private int getRuns() {
      return Integer.parseInt(this.spoofs.getValue());
   }

   private static enum exploitEn {
      Strong,
      Fast,
      Strict,
      Phobos;
   }
}
