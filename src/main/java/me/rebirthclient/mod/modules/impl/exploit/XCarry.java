//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "G:\PortableSoft\JBY\MC_Deobf3000\1.12-MCP-Mappings"!

package me.rebirthclient.mod.modules.impl.exploit;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import me.rebirthclient.api.events.impl.ClientEvent;
import me.rebirthclient.api.events.impl.PacketEvent;
import me.rebirthclient.api.util.InventoryUtil;
import me.rebirthclient.api.util.ReflectionUtil;
import me.rebirthclient.mod.gui.screen.Gui;
import me.rebirthclient.mod.modules.Category;
import me.rebirthclient.mod.modules.Module;
import me.rebirthclient.mod.modules.settings.Bind;
import me.rebirthclient.mod.modules.settings.Setting;
import net.minecraft.client.gui.inventory.GuiInventory;
import net.minecraft.inventory.Slot;
import net.minecraft.network.play.client.CPacketCloseWindow;
import net.minecraftforge.client.event.GuiOpenEvent;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.InputEvent.KeyInputEvent;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;

public class XCarry extends Module {
   public static XCarry INSTANCE = new XCarry();
   private final Setting<Boolean> simpleMode = this.add(new Setting<>("Simple", false));
   private final Setting<Bind> autoDuel = this.add(new Setting<>("AutoDuel", new Bind(-1)));
   private final Setting<Integer> obbySlot = this.add(new Setting<>("ObbySlot", 2, 1, 9, v -> this.autoDuel.getValue().getKey() != -1));
   private final Setting<Integer> slot1 = this.add(new Setting<>("Slot1", 22, 9, 44, v -> this.autoDuel.getValue().getKey() != -1));
   private final Setting<Integer> slot2 = this.add(new Setting<>("Slot2", 23, 9, 44, v -> this.autoDuel.getValue().getKey() != -1));
   private final Setting<Integer> slot3 = this.add(new Setting<>("Slot3", 24, 9, 44, v -> this.autoDuel.getValue().getKey() != -1));
   private final Setting<Integer> tasks = this.add(new Setting<>("Actions", 3, 1, 12, v -> this.autoDuel.getValue().getKey() != -1));
   private final Setting<Boolean> shiftClicker = this.add(new Setting<>("ShiftClick", false).setParent());
   private final Setting<Boolean> withShift = this.add(new Setting<>("WithShift", true, v -> this.shiftClicker.isOpen()));
   private final Setting<Bind> keyBind = this.add(new Setting<>("ShiftBind", new Bind(-1), v -> this.shiftClicker.isOpen()));
   private final AtomicBoolean shouldCloseGui = new AtomicBoolean(false);
   private final Queue<InventoryUtil.QueuedTask> queuedTaskList = new ConcurrentLinkedQueue<>();
   private GuiInventory openedGui;
   private boolean guiCloseGuard;
   private boolean autoDuelOn;
   private boolean obbySlotDone;
   private boolean slot1done;
   private boolean slot2done;
   private boolean slot3done;
   private List<Integer> doneSlots = new ArrayList<>();

   public XCarry() {
      super("XCarry", "Uses the crafting inventory for storage", Category.EXPLOIT);
      INSTANCE = this;
   }

   @Override
   public void onDisable() {
      if (!fullNullCheck()) {
         if (!this.simpleMode.getValue()) {
            this.closeGui();
            this.close();
         } else {
            mc.player.connection.sendPacket(new CPacketCloseWindow(mc.player.inventoryContainer.windowId));
         }
      }
   }

   @Override
   public void onLogout() {
      this.onDisable();
   }

   @Override
   public void onUpdate() {
      if (this.shiftClicker.getValue() && mc.currentScreen instanceof GuiInventory) {
         boolean ourBind = this.keyBind.getValue().getKey() != -1 && Keyboard.isKeyDown(this.keyBind.getValue().getKey()) && !Keyboard.isKeyDown(42);
         Slot slot;
         if ((Keyboard.isKeyDown(42) && this.withShift.getValue() || ourBind)
            && Mouse.isButtonDown(0)
            && (slot = ((GuiInventory)mc.currentScreen).getSlotUnderMouse()) != null
            && InventoryUtil.getEmptyXCarry() != -1) {
            int slotNumber = slot.slotNumber;
            if (slotNumber > 4 && ourBind) {
               this.queuedTaskList.add(new InventoryUtil.QueuedTask(slotNumber));
               this.queuedTaskList.add(new InventoryUtil.QueuedTask(InventoryUtil.getEmptyXCarry()));
            } else if (slotNumber > 4 && this.withShift.getValue()) {
               boolean isHotBarFull = true;
               boolean isInvFull = true;

               for(int i : InventoryUtil.findEmptySlots(false)) {
                  if (i > 4 && i < 36) {
                     isInvFull = false;
                  } else if (i > 35 && i < 45) {
                     isHotBarFull = false;
                  }
               }

               if (slotNumber > 35 && slotNumber < 45) {
                  if (isInvFull) {
                     this.queuedTaskList.add(new InventoryUtil.QueuedTask(slotNumber));
                     this.queuedTaskList.add(new InventoryUtil.QueuedTask(InventoryUtil.getEmptyXCarry()));
                  }
               } else if (isHotBarFull) {
                  this.queuedTaskList.add(new InventoryUtil.QueuedTask(slotNumber));
                  this.queuedTaskList.add(new InventoryUtil.QueuedTask(InventoryUtil.getEmptyXCarry()));
               }
            }
         }
      }

      if (this.autoDuelOn) {
         this.doneSlots = new ArrayList<>();
         if (InventoryUtil.getEmptyXCarry() == -1 || this.obbySlotDone && this.slot1done && this.slot2done && this.slot3done) {
            this.autoDuelOn = false;
         }

         if (this.autoDuelOn) {
            if (!this.obbySlotDone && !mc.player.inventory.getStackInSlot(this.obbySlot.getValue() - 1).isEmpty) {
               this.addTasks(36 + this.obbySlot.getValue() - 1);
            }

            this.obbySlotDone = true;
            if (!this.slot1done && !((Slot)mc.player.inventoryContainer.inventorySlots.get(this.slot1.getValue())).getStack().isEmpty) {
               this.addTasks(this.slot1.getValue());
            }

            this.slot1done = true;
            if (!this.slot2done && !((Slot)mc.player.inventoryContainer.inventorySlots.get(this.slot2.getValue())).getStack().isEmpty) {
               this.addTasks(this.slot2.getValue());
            }

            this.slot2done = true;
            if (!this.slot3done && !((Slot)mc.player.inventoryContainer.inventorySlots.get(this.slot3.getValue())).getStack().isEmpty) {
               this.addTasks(this.slot3.getValue());
            }

            this.slot3done = true;
         }
      } else {
         this.obbySlotDone = false;
         this.slot1done = false;
         this.slot2done = false;
         this.slot3done = false;
      }

      if (!this.queuedTaskList.isEmpty()) {
         for(int i = 0; i < this.tasks.getValue(); ++i) {
            InventoryUtil.QueuedTask queuedTask = this.queuedTaskList.poll();
            if (queuedTask != null) {
               queuedTask.run();
            }
         }
      }
   }

   @SubscribeEvent(
      priority = EventPriority.LOWEST
   )
   public void onGuiOpen(GuiOpenEvent event) {
      if (!fullNullCheck()) {
         if (!this.simpleMode.getValue()) {
            if (this.guiCloseGuard) {
               event.setCanceled(true);
            } else if (event.getGui() instanceof GuiInventory) {
               this.openedGui = this.createGuiWrapper((GuiInventory)event.getGui());
               event.setGui(this.openedGui);
               this.shouldCloseGui.set(false);
            }
         }
      }
   }

   @SubscribeEvent
   public void onGuiClose(PacketEvent.Send event) {
      if (!fullNullCheck()) {
         if (this.simpleMode.getValue() && event.getPacket() instanceof CPacketCloseWindow) {
            CPacketCloseWindow packet = event.getPacket();
            if (packet.windowId == mc.player.inventoryContainer.windowId) {
               event.setCanceled(true);
            }
         }
      }
   }

   @SubscribeEvent
   public void onSettingChange(ClientEvent event) {
      if (!fullNullCheck()) {
         if (event.getStage() == 2 && event.getSetting() != null && event.getSetting().getMod() != null && event.getSetting().getMod().equals(this)) {
            Setting setting = event.getSetting();
            String settingname = event.getSetting().getName();
            if (setting.equals(this.simpleMode) && setting.getPlannedValue() != setting.getValue()) {
               this.disable();
            } else if (settingname.equalsIgnoreCase("Store")) {
               event.setCanceled(true);
               this.autoDuelOn = !this.autoDuelOn;
               this.sendMessage("<XCarry> §aAutostoring...");
            }
         }
      }
   }

   @SubscribeEvent
   public void onKeyInput(KeyInputEvent event) {
      if (!fullNullCheck()) {
         if (Keyboard.getEventKeyState() && !(mc.currentScreen instanceof Gui) && this.autoDuel.getValue().getKey() == Keyboard.getEventKey()) {
            this.autoDuelOn = !this.autoDuelOn;
            this.sendMessage("<XCarry> §aAutostoring...");
         }
      }
   }

   private void addTasks(int slot) {
      if (InventoryUtil.getEmptyXCarry() != -1) {
         int xcarrySlot = InventoryUtil.getEmptyXCarry();
         if (this.doneSlots.contains(xcarrySlot) || !InventoryUtil.isSlotEmpty(xcarrySlot)) {
            ++xcarrySlot;
            if (this.doneSlots.contains(xcarrySlot) || !InventoryUtil.isSlotEmpty(xcarrySlot)) {
               ++xcarrySlot;
               if (this.doneSlots.contains(xcarrySlot) || !InventoryUtil.isSlotEmpty(xcarrySlot)) {
                  ++xcarrySlot;
                  if (this.doneSlots.contains(xcarrySlot) || !InventoryUtil.isSlotEmpty(xcarrySlot)) {
                     return;
                  }
               }
            }
         }

         if (xcarrySlot > 4) {
            return;
         }

         this.doneSlots.add(xcarrySlot);
         this.queuedTaskList.add(new InventoryUtil.QueuedTask(slot));
         this.queuedTaskList.add(new InventoryUtil.QueuedTask(xcarrySlot));
         this.queuedTaskList.add(new InventoryUtil.QueuedTask());
      }
   }

   private void close() {
      this.openedGui = null;
      this.shouldCloseGui.set(false);
      this.guiCloseGuard = false;
   }

   private void closeGui() {
      if (this.shouldCloseGui.compareAndSet(true, false) && !fullNullCheck()) {
         this.guiCloseGuard = true;
         if (mc.currentScreen != null) {
            mc.player.closeScreen();
         }

         if (this.openedGui != null) {
            this.openedGui.onGuiClosed();
            this.openedGui = null;
         }

         this.guiCloseGuard = false;
      }
   }

   private GuiInventory createGuiWrapper(GuiInventory gui) {
      try {
         XCarry.GuiInventoryWrapper wrapper = new XCarry.GuiInventoryWrapper();
         ReflectionUtil.copyOf(gui, wrapper);
         return wrapper;
      } catch (NoSuchFieldException | IllegalAccessException var3) {
         var3.printStackTrace();
         return null;
      }
   }

   private class GuiInventoryWrapper extends GuiInventory {
      GuiInventoryWrapper() {
         super(XCarry.mc.player);
      }

      protected void keyTyped(char typedChar, int keyCode) throws IOException {
         if (!XCarry.this.isOn() || keyCode != 1 && !this.mc.gameSettings.keyBindInventory.isActiveAndMatches(keyCode)) {
            super.keyTyped(typedChar, keyCode);
         } else {
            XCarry.this.shouldCloseGui.set(true);
            this.mc.displayGuiScreen(null);
         }
      }

      public void onGuiClosed() {
         if (XCarry.this.guiCloseGuard || !XCarry.this.isOn()) {
            super.onGuiClosed();
         }
      }
   }
}
