//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "G:\PortableSoft\JBY\MC_Deobf3000\1.12-MCP-Mappings"!

package me.rebirthclient.mod.modules.impl.exploit;

import java.util.Random;
import me.rebirthclient.api.events.impl.PacketEvent;
import me.rebirthclient.api.util.Timer;
import me.rebirthclient.mod.modules.Category;
import me.rebirthclient.mod.modules.Module;
import me.rebirthclient.mod.modules.settings.Setting;
import net.minecraft.init.Items;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.client.CPacketPlayerTryUseItem;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.network.play.client.CPacketPlayer.PositionRotation;
import net.minecraft.network.play.client.CPacketPlayerDigging.Action;
import net.minecraft.util.EnumHand;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class SuperThrow extends Module {
   public static Timer delayTimer = new Timer();
   public final Setting<Boolean> pearls = this.register(new Setting<>("EPearls", true));
   public final Setting<Boolean> xp = this.register(new Setting<>("XP", true));
   public final Setting<Boolean> eggs = this.register(new Setting<>("Eggs", true));
   public final Setting<Boolean> potions = this.register(new Setting<>("SplashPotions", true));
   public final Setting<Boolean> snowballs = this.register(new Setting<>("Snowballs", true));
   public Setting<Boolean> rotation = this.add(new Setting<>("Rotation", false));
   public Setting<SuperThrow.ModeEn> Mode = this.add(new Setting<>("Mode", SuperThrow.ModeEn.Maximum));
   public Setting<Float> factor = this.add(new Setting<>("Factor", 1.0F, 1.0F, 20.0F));
   public Setting<SuperThrow.exploitEn> exploit = this.add(new Setting<>("Exploit", SuperThrow.exploitEn.Strong));
   public Setting<Boolean> minimize = this.add(new Setting<>("Minimize", false));
   public Setting<Float> delay = this.add(new Setting<>("Delay", 5.0F, 0.0F, 10.0F));
   private final Random rnd = new Random();

   public SuperThrow() {
      super("SuperThrow", "exploit", Category.EXPLOIT);
   }

   @SubscribeEvent
   protected void onPacketSend(PacketEvent.Send event) {
      if (!fullNullCheck() && delayTimer.passedMs((long)(this.delay.getValue() * 1000.0F))) {
         if (event.getPacket() instanceof CPacketPlayerDigging && ((CPacketPlayerDigging)event.getPacket()).getAction() == Action.RELEASE_USE_ITEM) {
            mc.player.getActiveItemStack().getItem();
         }

         if (event.getPacket() instanceof CPacketPlayerTryUseItem
            && ((CPacketPlayerTryUseItem)event.getPacket()).getHand() == EnumHand.MAIN_HAND
            && (
               mc.player.getHeldItemMainhand().getItem() == Items.ENDER_PEARL && this.pearls.getValue()
                  || mc.player.getHeldItemMainhand().getItem() == Items.EXPERIENCE_BOTTLE && this.xp.getValue()
                  || mc.player.getHeldItemMainhand().getItem() == Items.EGG && this.eggs.getValue()
                  || mc.player.getHeldItemMainhand().getItem() == Items.SPLASH_POTION && this.potions.getValue()
                  || mc.player.getHeldItemMainhand().getItem() == Items.SNOWBALL && this.snowballs.getValue()
            )) {
            mc.player
               .connection
               .sendPacket(new CPacketEntityAction(mc.player, net.minecraft.network.play.client.CPacketEntityAction.Action.START_SPRINTING));
            double[] strict_direction = new double[]{
               100.0 * -Math.sin(Math.toRadians((double)mc.player.rotationYaw)),
               100.0 * Math.cos(Math.toRadians((double)mc.player.rotationYaw))
            };
            if (this.exploit.getValue() == SuperThrow.exploitEn.Fast) {
               for(int i = 0; i < this.getRuns(); ++i) {
                  this.spoof(
                     mc.player.posX,
                     this.minimize.getValue() ? mc.player.posY : mc.player.posY - 1.0E-1,
                     mc.player.posZ,
                     true
                  );
                  this.spoof(mc.player.posX, mc.player.posY + 1.0E-1, mc.player.posZ, false);
               }
            }

            if (this.exploit.getValue() == SuperThrow.exploitEn.Strong) {
               for(int i = 0; i < this.getRuns(); ++i) {
                  this.spoof(mc.player.posX, mc.player.posY + 1.0E-1, mc.player.posZ, false);
                  this.spoof(
                     mc.player.posX,
                     this.minimize.getValue() ? mc.player.posY : mc.player.posY - 1.0E-1,
                     mc.player.posZ,
                     true
                  );
               }
            }

            if (this.exploit.getValue() == SuperThrow.exploitEn.Phobos) {
               for(int i = 0; i < this.getRuns(); ++i) {
                  this.spoof(mc.player.posX, mc.player.posY + 1.3E-13, mc.player.posZ, true);
                  this.spoof(mc.player.posX, mc.player.posY + 2.7E-13, mc.player.posZ, false);
               }
            }

            if (this.exploit.getValue() == SuperThrow.exploitEn.Strict) {
               for(int i = 0; i < this.getRuns(); ++i) {
                  if (this.rnd.nextBoolean()) {
                     this.spoof(
                        mc.player.posX - strict_direction[0],
                        mc.player.posY,
                        mc.player.posZ - strict_direction[1],
                        false
                     );
                  } else {
                     this.spoof(
                        mc.player.posX + strict_direction[0],
                        mc.player.posY,
                        mc.player.posZ + strict_direction[1],
                        true
                     );
                  }
               }
            }

            delayTimer.reset();
         }
      }
   }

   private void spoof(double x, double y, double z, boolean ground) {
      if (this.rotation.getValue()) {
         mc.player.connection.sendPacket(new PositionRotation(x, y, z, mc.player.rotationYaw, mc.player.rotationPitch, ground));
      } else {
         mc.player.connection.sendPacket(new Position(x, y, z, ground));
      }
   }

   private int getRuns() {
      if (this.Mode.getValue() == SuperThrow.ModeEn.Factorised) {
         return 10 + (int)(this.factor.getValue() - 1.0F);
      } else if (this.Mode.getValue() == SuperThrow.ModeEn.Normal) {
         return (int)Math.floor((double)this.factor.getValue().floatValue());
      } else {
         return this.Mode.getValue() == SuperThrow.ModeEn.Maximum ? (int)(30.0F * this.factor.getValue()) : 1;
      }
   }

   private static enum ModeEn {
      Normal,
      Maximum,
      Factorised;
   }

   private static enum exploitEn {
      Strong,
      Fast,
      Strict,
      Phobos;
   }
}
