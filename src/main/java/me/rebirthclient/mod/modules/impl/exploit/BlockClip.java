//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "G:\PortableSoft\JBY\MC_Deobf3000\1.12-MCP-Mappings"!

package me.rebirthclient.mod.modules.impl.exploit;

import me.rebirthclient.api.events.impl.PacketEvent;
import me.rebirthclient.api.events.impl.UpdateWalkingPlayerEvent;
import me.rebirthclient.api.util.MovementUtil;
import me.rebirthclient.api.util.PositionUtil;
import me.rebirthclient.api.util.Timer;
import me.rebirthclient.mod.modules.Category;
import me.rebirthclient.mod.modules.Module;
import me.rebirthclient.mod.modules.settings.Setting;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3i;
import net.minecraft.util.math.BlockPos.MutableBlockPos;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class BlockClip extends Module {
   public static BlockClip INSTANCE;
   private final Setting<Integer> movementTimeout = this.add(new Setting<>("Movement Timeout", 1000, 0, 5000));
   private final Setting<Integer> interval = this.add(new Setting<>("Interval", 0, 0, 5000));
   private int fixTicks = -1;
   private final Timer enableTimer = new Timer();
   private final Timer clipTimer = new Timer();
   private final double[] offsets = new double[]{-0.15, -0.1, 0.0, 0.044};

   public BlockClip() {
      super("BlockClip", "BlockClips into blocks nearby to prevent crystal damage", Category.EXPLOIT);
      INSTANCE = this;
   }

   @Override
   public void onEnable() {
      this.fixTicks = -1;
      this.enableTimer.reset();
   }

   @SubscribeEvent
   public void onReceivePacket(PacketEvent.Receive event) {
      if (!fullNullCheck()) {
         if (!event.isCanceled()) {
            if (event.getPacket() instanceof SPacketPlayerPosLook) {
               this.fixTicks = 0;
            }
         }
      }
   }

   @SubscribeEvent
   public void onUpdateWalkingPlayer(UpdateWalkingPlayerEvent event) {
      if (!fullNullCheck()) {
         if (event.getStage() != 0) {
            if (!MovementUtil.isJumping() && !MovementUtil.isMoving()) {
               if (this.enableTimer.passedMs((long)this.movementTimeout.getValue().intValue())
                  && this.clipTimer.passedMs((long)this.interval.getValue().intValue())) {
                  EntityPlayerSP player = mc.player;
                  BlockPos playerPos = PositionUtil.getPosition();
                  MutableBlockPos pos = new MutableBlockPos();
                  double posX = player.posX;
                  double posZ = player.posZ;
                  double offset = this.offsets[Math.max(this.fixTicks, 0)];
                  boolean fixing = this.fixTicks < this.offsets.length - 1;
                  boolean collided = false;
                  boolean clipX = hasCollisionBox(mc.world, this.setAndAdd(pos, playerPos, 1, 0, 0));
                  boolean clipZ = hasCollisionBox(mc.world, this.setAndAdd(pos, playerPos, 0, 0, 1));
                  boolean clipX2 = hasCollisionBox(mc.world, this.setAndAdd(pos, playerPos, -1, 0, 0));
                  boolean clipZ2 = hasCollisionBox(mc.world, this.setAndAdd(pos, playerPos, 0, 0, -1));
                  if (clipX) {
                     collided = true;
                     posX = (double)fastFloor(posX) + 0.7 + offset;
                  } else if (clipX2) {
                     collided = true;
                     posX = (double)fastFloor(posX) - 0.7 - offset;
                  }

                  if (clipZ) {
                     collided = true;
                     posZ = (double)fastFloor(posZ) + 0.7 + offset;
                  } else if (clipZ2) {
                     collided = true;
                     posZ = (double)fastFloor(posZ) - 0.7 - offset;
                  }

                  if (!clipZ && !clipX && !clipX2 && !clipZ2) {
                     if (hasCollisionBox(mc.world, this.setAndAdd(pos, playerPos, 1, 0, 1))) {
                        collided = true;
                        posX = (double)fastFloor(posX) + 0.7 + offset;
                        posZ = (double)fastFloor(posZ) + 0.7 + offset;
                     } else if (hasCollisionBox(mc.world, this.setAndAdd(pos, playerPos, -1, 0, -1))) {
                        collided = true;
                        posX = (double)fastFloor(posX) - 0.7 - offset;
                        posZ = (double)fastFloor(posZ) - 0.7 - offset;
                     } else if (hasCollisionBox(mc.world, this.setAndAdd(pos, playerPos, 1, 0, -1))) {
                        collided = true;
                        posX = (double)fastFloor(posX) + 0.7 + offset;
                        posZ = (double)fastFloor(posZ) - 0.7 - offset;
                     } else if (hasCollisionBox(mc.world, this.setAndAdd(pos, playerPos, -1, 0, 1))) {
                        collided = true;
                        posX = (double)fastFloor(posX) - 0.7 - offset;
                        posZ = (double)fastFloor(posZ) + 0.7 + offset;
                     }
                  }

                  if (collided) {
                     mc.player.setPosition(posX, mc.player.posY, posZ);
                     if (fixing) {
                        ++this.fixTicks;
                        if (this.fixTicks == this.offsets.length - 1) {
                           mc.player
                              .connection
                              .sendPacket(new Position(posX, mc.player.posY, posZ, mc.player.onGround));
                        }
                     }
                  }
               }
            } else {
               this.fixTicks = 0;
               this.enableTimer.reset();
            }
         }
      }
   }

   public static AxisAlignedBB getCollisionBox(World world, BlockPos pos) {
      return world.getBlockState(pos).getCollisionBoundingBox(world, pos);
   }

   public static boolean hasCollisionBox(World world, BlockPos pos) {
      return getCollisionBox(world, pos) != null;
   }

   public static int fastFloor(double count) {
      return (int)(count + 1.07374182E9F) - 1073741824;
   }

   public MutableBlockPos setAndAdd(MutableBlockPos mutableBlockPos, Vec3i set, int x, int y, int z) {
      return mutableBlockPos.setPos(set.getX() + x, set.getY() + y, set.getZ() + z);
   }
}
