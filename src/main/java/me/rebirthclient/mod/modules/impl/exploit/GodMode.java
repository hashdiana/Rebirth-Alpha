//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "G:\PortableSoft\JBY\MC_Deobf3000\1.12-MCP-Mappings"!

package me.rebirthclient.mod.modules.impl.exploit;

import me.rebirthclient.api.events.impl.PacketEvent;
import me.rebirthclient.api.events.impl.UpdateWalkingPlayerEvent;
import me.rebirthclient.mod.modules.Category;
import me.rebirthclient.mod.modules.Module;
import me.rebirthclient.mod.modules.settings.Setting;
import net.minecraft.entity.Entity;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketInput;
import net.minecraft.network.play.client.CPacketVehicleMove;
import net.minecraft.network.play.client.CPacketEntityAction.Action;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.network.play.client.CPacketPlayer.PositionRotation;
import net.minecraft.network.play.client.CPacketPlayer.Rotation;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class GodMode extends Module {
   private final Setting<Boolean> remount = this.add(new Setting<>("Remount", false));
   private Entity entity;

   public GodMode() {
      super("GodMode", "test", Category.EXPLOIT);
   }

   @Override
   public void onEnable() {
      if (mc.world != null && mc.player.getRidingEntity() != null) {
         this.entity = mc.player.getRidingEntity();
         mc.renderGlobal.loadRenderers();
         this.hideEntity();
         mc.player
            .setPosition(
               (double)mc.player.getPosition().getX(),
               (double)(mc.player.getPosition().getY() - 1),
               (double)mc.player.getPosition().getZ()
            );
      }

      if (mc.world != null && this.remount.getValue()) {
         this.remount.setValue(false);
      }
   }

   @Override
   public void onDisable() {
      if (this.remount.getValue()) {
         this.remount.setValue(false);
      }

      if (!nullCheck()) {
         mc.player.dismountRidingEntity();
         mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, Action.START_SNEAKING));
         mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, Action.STOP_SNEAKING));
      }
   }

   @SubscribeEvent
   public void onPacketSend(PacketEvent.Send event) {
      if (!fullNullCheck()) {
         if (event.getPacket() instanceof Position || event.getPacket() instanceof PositionRotation) {
            event.setCanceled(true);
         }
      }
   }

   private void hideEntity() {
      if (mc.player.getRidingEntity() != null) {
         mc.player.dismountRidingEntity();
         mc.world.removeEntity(this.entity);
      }
   }

   private void showEntity(Entity entity2) {
      entity2.isDead = false;
      mc.world.loadedEntityList.add(entity2);
      mc.player.startRiding(entity2, true);
   }

   @SubscribeEvent
   public void onPlayerWalkingUpdate(UpdateWalkingPlayerEvent event) {
      if (!fullNullCheck()) {
         if (this.entity != null) {
            if (event.getStage() == 0) {
               if (this.remount.getValue()) {
                  this.showEntity(this.entity);
               }

               this.entity
                  .setPositionAndRotation(
                     mc.player.posX,
                     mc.player.posY,
                     mc.player.posZ,
                     mc.player.rotationYaw,
                     mc.player.rotationPitch
                  );
               mc.player.connection.sendPacket(new Rotation(mc.player.rotationYaw, mc.player.rotationPitch, true));
               mc.player
                  .connection
                  .sendPacket(new CPacketInput(mc.player.movementInput.moveForward, mc.player.movementInput.moveStrafe, false, false));
               mc.player.connection.sendPacket(new CPacketVehicleMove(this.entity));
            }
         }
      }
   }
}
