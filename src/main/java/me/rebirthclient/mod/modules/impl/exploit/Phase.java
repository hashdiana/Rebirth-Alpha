//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "G:\PortableSoft\JBY\MC_Deobf3000\1.12-MCP-Mappings"!

package me.rebirthclient.mod.modules.impl.exploit;

import me.rebirthclient.api.util.math.MathUtil;
import me.rebirthclient.mod.modules.Category;
import me.rebirthclient.mod.modules.Module;
import me.rebirthclient.mod.modules.settings.Setting;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketEntityAction.Action;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.network.play.client.CPacketPlayer.PositionRotation;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.RayTraceResult.Type;

public class Phase extends Module {
   private final Setting<Boolean> PhaseCheck = this.add(new Setting<>("Only In Block", false));
   private final Setting<Phase.NoClipMode> noClipMode = this.add(new Setting<>("NoClipMode", Phase.NoClipMode.Bypass));
   private final Setting<Boolean> fallPacket = this.add(new Setting<>("Fall Packet", true));
   private final Setting<Boolean> sprintPacket = this.add(new Setting<>("Sprint Packet", true));
   private final Setting<Boolean> instantWalk = this.add(new Setting<>("Instant Walk", false));
   private final Setting<Boolean> antiVoid = this.add(new Setting<>("Anti Void", false));
   private final Setting<Integer> antiVoidHeight = this.add(new Setting<>("Anti Void Height", 5, 1, 100));
   private final Setting<Double> instantWalkSpeed = this.add(new Setting<>("Instant Speed", 0.1, 0.1, 2.0, v -> this.instantWalk.getValue()));
   private final Setting<Double> PhaseSpeed = this.add(new Setting<>("Phase Walk Speed", 0.1, 0.1, 70.0));
   private final Setting<Boolean> downOnShift = this.add(new Setting<>("Phase Down When Crouch", true));
   private final Setting<Boolean> stopMotion = this.add(new Setting<>("Attempt Clips", true));
   private final Setting<Integer> stopMotionDelay = this.add(new Setting<>("Attempt Clips Delay", 5, 0, 20, v -> this.stopMotion.getValue()));
   int delay = 0;

   public Phase() {
      super("Phase", "Fuck wall", Category.EXPLOIT);
   }

   @Override
   public void onUpdate() {
      ++this.delay;
      double PhaseSpeedValue = this.PhaseSpeed.getValue() / 1000.0;
      double instantSpeedValue = this.instantWalkSpeed.getValue() / 10.0;
      if (this.antiVoid.getValue() && mc.player.posY <= (double)this.antiVoidHeight.getValue().intValue()) {
         RayTraceResult trace = mc.world
            .rayTraceBlocks(
               mc.player.getPositionVector(), new Vec3d(mc.player.posX, 0.0, mc.player.posZ), false, false, false
            );
         if (trace == null || trace.typeOfHit != Type.BLOCK) {
            mc.player.setVelocity(0.0, 0.0, 0.0);
         }
      }

      if (this.PhaseCheck.getValue()) {
         if ((
               mc.gameSettings.keyBindForward.isKeyDown()
                  || mc.gameSettings.keyBindRight.isKeyDown()
                  || mc.gameSettings.keyBindLeft.isKeyDown()
                  || mc.gameSettings.keyBindBack.isKeyDown()
                  || mc.gameSettings.keyBindSneak.isKeyDown()
            )
            && (
               !this.eChestCheck() && !mc.world.getBlockState(this.getPlayerPos()).getBlock().equals(Blocks.AIR)
                  || !mc.world.getBlockState(this.getPlayerPos().up()).getBlock().equals(Blocks.AIR)
            )) {
            if (mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isPressed() && mc.player.isSneaking()) {
               double[] dirSpeed = this.getMotion(PhaseSpeedValue);
               if (this.downOnShift.getValue() && mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isKeyDown()) {
                  mc.player
                     .connection
                     .sendPacket(
                        new PositionRotation(
                           mc.player.posX + dirSpeed[0],
                           mc.player.posY - 0.0424,
                           mc.player.posZ + dirSpeed[1],
                           mc.player.rotationYaw,
                           mc.player.rotationPitch,
                           false
                        )
                     );
               } else {
                  mc.player
                     .connection
                     .sendPacket(
                        new PositionRotation(
                           mc.player.posX + dirSpeed[0],
                           mc.player.posY,
                           mc.player.posZ + dirSpeed[1],
                           mc.player.rotationYaw,
                           mc.player.rotationPitch,
                           false
                        )
                     );
               }

               if (this.noClipMode.getValue() == Phase.NoClipMode.Fall) {
                  mc.player
                     .connection
                     .sendPacket(
                        new PositionRotation(
                           mc.player.posX,
                           -1300.0,
                           mc.player.posZ,
                           mc.player.rotationYaw * -5.0F,
                           mc.player.rotationPitch * -5.0F,
                           true
                        )
                     );
               }

               if (this.noClipMode.getValue() == Phase.NoClipMode.NoClip) {
                  mc.player.setVelocity(0.0, 0.0, 0.0);
                  if (mc.gameSettings.keyBindForward.isKeyDown()
                     || mc.gameSettings.keyBindBack.isKeyDown()
                     || mc.gameSettings.keyBindLeft.isKeyDown()
                     || mc.gameSettings.keyBindRight.isKeyDown()) {
                     double[] speed = MathUtil.directionSpeed(0.06F);
                     mc.player
                        .connection
                        .sendPacket(
                           new Position(
                              mc.player.posX + speed[0],
                              mc.player.posY,
                              mc.player.posZ + speed[1],
                              mc.player.onGround
                           )
                        );
                     mc.player
                        .connection
                        .sendPacket(new Position(mc.player.posX, 0.0, mc.player.posZ, mc.player.onGround));
                  }

                  if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                     mc.player
                        .connection
                        .sendPacket(
                           new Position(
                              mc.player.posX,
                              mc.player.posY - 0.06F,
                              mc.player.posZ,
                              mc.player.onGround
                           )
                        );
                     mc.player
                        .connection
                        .sendPacket(new Position(mc.player.posX, 0.0, mc.player.posZ, mc.player.onGround));
                  }

                  if (mc.gameSettings.keyBindJump.isKeyDown()) {
                     mc.player
                        .connection
                        .sendPacket(
                           new Position(
                              mc.player.posX,
                              mc.player.posY + 0.06F,
                              mc.player.posZ,
                              mc.player.onGround
                           )
                        );
                     mc.player
                        .connection
                        .sendPacket(new Position(mc.player.posX, 0.0, mc.player.posZ, mc.player.onGround));
                  }
               }

               if (this.noClipMode.getValue() == Phase.NoClipMode.Bypass) {
                  mc.player.noClip = true;
               }

               if (this.fallPacket.getValue()) {
                  mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, Action.STOP_RIDING_JUMP));
               }

               if (this.sprintPacket.getValue()) {
                  mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, Action.START_SPRINTING));
               }

               if (this.downOnShift.getValue() && mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isKeyDown()) {
                  mc.player
                     .setPosition(
                        mc.player.posX + dirSpeed[0], mc.player.posY - 0.0424, mc.player.posZ + dirSpeed[1]
                     );
               } else {
                  mc.player
                     .setPosition(mc.player.posX + dirSpeed[0], mc.player.posY, mc.player.posZ + dirSpeed[1]);
               }

               mc.player.motionZ = 0.0;
               mc.player.motionY = 0.0;
               mc.player.motionX = 0.0;
               mc.player.noClip = true;
            }

            if (mc.player.collidedHorizontally && this.stopMotion.getValue() ? this.delay >= this.stopMotionDelay.getValue() : mc.player.collidedHorizontally) {
               double[] dirSpeed = this.getMotion(PhaseSpeedValue);
               if (this.downOnShift.getValue() && mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isKeyDown()) {
                  mc.player
                     .connection
                     .sendPacket(
                        new PositionRotation(
                           mc.player.posX + dirSpeed[0],
                           mc.player.posY - 0.1,
                           mc.player.posZ + dirSpeed[1],
                           mc.player.rotationYaw,
                           mc.player.rotationPitch,
                           false
                        )
                     );
               } else {
                  mc.player
                     .connection
                     .sendPacket(
                        new PositionRotation(
                           mc.player.posX + dirSpeed[0],
                           mc.player.posY,
                           mc.player.posZ + dirSpeed[1],
                           mc.player.rotationYaw,
                           mc.player.rotationPitch,
                           false
                        )
                     );
               }

               if (this.noClipMode.getValue() == Phase.NoClipMode.Fall) {
                  mc.player
                     .connection
                     .sendPacket(
                        new PositionRotation(
                           mc.player.posX,
                           -1300.0,
                           mc.player.posZ,
                           mc.player.rotationYaw * -5.0F,
                           mc.player.rotationPitch * -5.0F,
                           true
                        )
                     );
               }

               if (this.noClipMode.getValue() == Phase.NoClipMode.NoClip) {
                  mc.player.setVelocity(0.0, 0.0, 0.0);
                  if (mc.gameSettings.keyBindForward.isKeyDown()
                     || mc.gameSettings.keyBindBack.isKeyDown()
                     || mc.gameSettings.keyBindLeft.isKeyDown()
                     || mc.gameSettings.keyBindRight.isKeyDown()) {
                     double[] speed = MathUtil.directionSpeed(0.06F);
                     mc.player
                        .connection
                        .sendPacket(
                           new Position(
                              mc.player.posX + speed[0],
                              mc.player.posY,
                              mc.player.posZ + speed[1],
                              mc.player.onGround
                           )
                        );
                     mc.player
                        .connection
                        .sendPacket(new Position(mc.player.posX, 0.0, mc.player.posZ, mc.player.onGround));
                  }

                  if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                     mc.player
                        .connection
                        .sendPacket(
                           new Position(
                              mc.player.posX,
                              mc.player.posY - 0.06F,
                              mc.player.posZ,
                              mc.player.onGround
                           )
                        );
                     mc.player
                        .connection
                        .sendPacket(new Position(mc.player.posX, 0.0, mc.player.posZ, mc.player.onGround));
                  }

                  if (mc.gameSettings.keyBindJump.isKeyDown()) {
                     mc.player
                        .connection
                        .sendPacket(
                           new Position(
                              mc.player.posX,
                              mc.player.posY + 0.06F,
                              mc.player.posZ,
                              mc.player.onGround
                           )
                        );
                     mc.player
                        .connection
                        .sendPacket(new Position(mc.player.posX, 0.0, mc.player.posZ, mc.player.onGround));
                  }
               }

               if (this.noClipMode.getValue() == Phase.NoClipMode.Bypass) {
                  mc.player.noClip = true;
               }

               if (this.fallPacket.getValue()) {
                  mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, Action.STOP_RIDING_JUMP));
               }

               if (this.sprintPacket.getValue()) {
                  mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, Action.START_SPRINTING));
               }

               if (this.downOnShift.getValue() && mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isKeyDown()) {
                  mc.player
                     .setPosition(
                        mc.player.posX + dirSpeed[0], mc.player.posY - 0.1, mc.player.posZ + dirSpeed[1]
                     );
               } else {
                  mc.player
                     .setPosition(mc.player.posX + dirSpeed[0], mc.player.posY, mc.player.posZ + dirSpeed[1]);
               }

               mc.player.motionZ = 0.0;
               mc.player.motionY = 0.0;
               mc.player.motionX = 0.0;
               mc.player.noClip = true;
               this.delay = 0;
               return;
            }

            if (this.instantWalk.getValue()) {
               double[] dir = MathUtil.directionSpeed(instantSpeedValue);
               mc.player.motionX = dir[0];
               mc.player.motionZ = dir[1];
            }
         }
      } else if (mc.gameSettings.keyBindForward.isKeyDown()
         || mc.gameSettings.keyBindRight.isKeyDown()
         || mc.gameSettings.keyBindLeft.isKeyDown()
         || mc.gameSettings.keyBindBack.isKeyDown()
         || mc.gameSettings.keyBindSneak.isKeyDown()) {
         if (mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isPressed() && mc.player.isSneaking()) {
            double[] dirSpeed = this.getMotion(PhaseSpeedValue);
            if (this.downOnShift.getValue() && mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isKeyDown()) {
               mc.player
                  .connection
                  .sendPacket(
                     new PositionRotation(
                        mc.player.posX + dirSpeed[0],
                        mc.player.posY - 0.0424,
                        mc.player.posZ + dirSpeed[1],
                        mc.player.rotationYaw,
                        mc.player.rotationPitch,
                        false
                     )
                  );
            } else {
               mc.player
                  .connection
                  .sendPacket(
                     new PositionRotation(
                        mc.player.posX + dirSpeed[0],
                        mc.player.posY,
                        mc.player.posZ + dirSpeed[1],
                        mc.player.rotationYaw,
                        mc.player.rotationPitch,
                        false
                     )
                  );
            }

            if (this.noClipMode.getValue() == Phase.NoClipMode.Fall) {
               mc.player
                  .connection
                  .sendPacket(
                     new PositionRotation(
                        mc.player.posX,
                        -1300.0,
                        mc.player.posZ,
                        mc.player.rotationYaw * -5.0F,
                        mc.player.rotationPitch * -5.0F,
                        true
                     )
                  );
            }

            if (this.noClipMode.getValue() == Phase.NoClipMode.NoClip) {
               mc.player.setVelocity(0.0, 0.0, 0.0);
               if (mc.gameSettings.keyBindForward.isKeyDown()
                  || mc.gameSettings.keyBindBack.isKeyDown()
                  || mc.gameSettings.keyBindLeft.isKeyDown()
                  || mc.gameSettings.keyBindRight.isKeyDown()) {
                  double[] speed = MathUtil.directionSpeed(0.06F);
                  mc.player
                     .connection
                     .sendPacket(
                        new Position(
                           mc.player.posX + speed[0],
                           mc.player.posY,
                           mc.player.posZ + speed[1],
                           mc.player.onGround
                        )
                     );
                  mc.player
                     .connection
                     .sendPacket(new Position(mc.player.posX, 0.0, mc.player.posZ, mc.player.onGround));
               }

               if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                  mc.player
                     .connection
                     .sendPacket(
                        new Position(
                           mc.player.posX,
                           mc.player.posY - 0.06F,
                           mc.player.posZ,
                           mc.player.onGround
                        )
                     );
                  mc.player
                     .connection
                     .sendPacket(new Position(mc.player.posX, 0.0, mc.player.posZ, mc.player.onGround));
               }

               if (mc.gameSettings.keyBindJump.isKeyDown()) {
                  mc.player
                     .connection
                     .sendPacket(
                        new Position(
                           mc.player.posX,
                           mc.player.posY + 0.06F,
                           mc.player.posZ,
                           mc.player.onGround
                        )
                     );
                  mc.player
                     .connection
                     .sendPacket(new Position(mc.player.posX, 0.0, mc.player.posZ, mc.player.onGround));
               }
            }

            if (this.noClipMode.getValue() == Phase.NoClipMode.Bypass) {
               mc.player.noClip = true;
            }

            if (this.fallPacket.getValue()) {
               mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, Action.STOP_RIDING_JUMP));
            }

            if (this.sprintPacket.getValue()) {
               mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, Action.START_SPRINTING));
            }

            if (this.downOnShift.getValue() && mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isKeyDown()) {
               mc.player
                  .setPosition(
                     mc.player.posX + dirSpeed[0], mc.player.posY - 0.0424, mc.player.posZ + dirSpeed[1]
                  );
            } else {
               mc.player
                  .setPosition(mc.player.posX + dirSpeed[0], mc.player.posY, mc.player.posZ + dirSpeed[1]);
            }

            mc.player.motionZ = 0.0;
            mc.player.motionY = 0.0;
            mc.player.motionX = 0.0;
            mc.player.noClip = true;
         }

         if (mc.player.collidedHorizontally && this.stopMotion.getValue() ? this.delay >= this.stopMotionDelay.getValue() : mc.player.collidedHorizontally) {
            double[] dirSpeed = this.getMotion(PhaseSpeedValue);
            if (this.downOnShift.getValue() && mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isKeyDown()) {
               mc.player
                  .connection
                  .sendPacket(
                     new PositionRotation(
                        mc.player.posX + dirSpeed[0],
                        mc.player.posY - 0.1,
                        mc.player.posZ + dirSpeed[1],
                        mc.player.rotationYaw,
                        mc.player.rotationPitch,
                        false
                     )
                  );
            } else {
               mc.player
                  .connection
                  .sendPacket(
                     new PositionRotation(
                        mc.player.posX + dirSpeed[0],
                        mc.player.posY,
                        mc.player.posZ + dirSpeed[1],
                        mc.player.rotationYaw,
                        mc.player.rotationPitch,
                        false
                     )
                  );
            }

            if (this.noClipMode.getValue() == Phase.NoClipMode.Fall) {
               mc.player
                  .connection
                  .sendPacket(
                     new PositionRotation(
                        mc.player.posX,
                        -1300.0,
                        mc.player.posZ,
                        mc.player.rotationYaw * -5.0F,
                        mc.player.rotationPitch * -5.0F,
                        true
                     )
                  );
            }

            if (this.noClipMode.getValue() == Phase.NoClipMode.NoClip) {
               mc.player.setVelocity(0.0, 0.0, 0.0);
               if (mc.gameSettings.keyBindForward.isKeyDown()
                  || mc.gameSettings.keyBindBack.isKeyDown()
                  || mc.gameSettings.keyBindLeft.isKeyDown()
                  || mc.gameSettings.keyBindRight.isKeyDown()) {
                  double[] speed = MathUtil.directionSpeed(0.06F);
                  mc.player
                     .connection
                     .sendPacket(
                        new Position(
                           mc.player.posX + speed[0],
                           mc.player.posY,
                           mc.player.posZ + speed[1],
                           mc.player.onGround
                        )
                     );
                  mc.player
                     .connection
                     .sendPacket(new Position(mc.player.posX, 0.0, mc.player.posZ, mc.player.onGround));
               }

               if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                  mc.player
                     .connection
                     .sendPacket(
                        new Position(
                           mc.player.posX,
                           mc.player.posY - 0.06F,
                           mc.player.posZ,
                           mc.player.onGround
                        )
                     );
                  mc.player
                     .connection
                     .sendPacket(new Position(mc.player.posX, 0.0, mc.player.posZ, mc.player.onGround));
               }

               if (mc.gameSettings.keyBindJump.isKeyDown()) {
                  mc.player
                     .connection
                     .sendPacket(
                        new Position(
                           mc.player.posX,
                           mc.player.posY + 0.06F,
                           mc.player.posZ,
                           mc.player.onGround
                        )
                     );
                  mc.player
                     .connection
                     .sendPacket(new Position(mc.player.posX, 0.0, mc.player.posZ, mc.player.onGround));
               }
            }

            if (this.noClipMode.getValue() == Phase.NoClipMode.Bypass) {
               mc.player.noClip = true;
            }

            if (this.fallPacket.getValue()) {
               mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, Action.STOP_RIDING_JUMP));
            }

            if (this.sprintPacket.getValue()) {
               mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, Action.START_SPRINTING));
            }

            if (this.downOnShift.getValue() && mc.player.collidedVertically && mc.gameSettings.keyBindSneak.isKeyDown()) {
               mc.player
                  .setPosition(
                     mc.player.posX + dirSpeed[0], mc.player.posY - 0.1, mc.player.posZ + dirSpeed[1]
                  );
            } else {
               mc.player
                  .setPosition(mc.player.posX + dirSpeed[0], mc.player.posY, mc.player.posZ + dirSpeed[1]);
            }

            mc.player.motionZ = 0.0;
            mc.player.motionY = 0.0;
            mc.player.motionX = 0.0;
            mc.player.noClip = true;
            this.delay = 0;
            return;
         }

         if (this.instantWalk.getValue()) {
            double[] dir = MathUtil.directionSpeed(instantSpeedValue);
            mc.player.motionX = dir[0];
            mc.player.motionZ = dir[1];
         }
      }
   }

   private BlockPos getPlayerPos() {
      return new BlockPos(Math.floor(mc.player.posX), Math.floor(mc.player.posY), Math.floor(mc.player.posZ));
   }

   private double[] getMotion(double speed) {
      float moveForward = mc.player.movementInput.moveForward;
      float moveStrafe = mc.player.movementInput.moveStrafe;
      float rotationYaw = mc.player.prevRotationYaw + (mc.player.rotationYaw - mc.player.prevRotationYaw) * mc.getRenderPartialTicks();
      if (moveForward != 0.0F) {
         if (moveStrafe > 0.0F) {
            rotationYaw += (float)(moveForward > 0.0F ? -45 : 45);
         } else if (moveStrafe < 0.0F) {
            rotationYaw += (float)(moveForward > 0.0F ? 45 : -45);
         }

         moveStrafe = 0.0F;
         if (moveForward > 0.0F) {
            moveForward = 1.0F;
         } else if (moveForward < 0.0F) {
            moveForward = -1.0F;
         }
      }

      double posX = (double)moveForward * speed * -Math.sin(Math.toRadians((double)rotationYaw))
         + (double)moveStrafe * speed * Math.cos(Math.toRadians((double)rotationYaw));
      double posZ = (double)moveForward * speed * Math.cos(Math.toRadians((double)rotationYaw))
         - (double)moveStrafe * speed * -Math.sin(Math.toRadians((double)rotationYaw));
      return new double[]{posX, posZ};
   }

   @Override
   public void onDisable() {
      mc.player.noClip = false;
   }

   private boolean eChestCheck() {
      String loc = String.valueOf(mc.player.posY);
      String deciaml = loc.split("\\.")[1];
      return deciaml.equals("875");
   }

   public static enum NoClipMode {
      NoClip,
      Fall,
      Bypass,
      None;
   }
}
